---
title: Unity-Shader(一)
date: 2020-09-25 17:19:00
tags:
    - Unity
    - Shader
---
# 渲染流水线
渲染流水线的工作是将一个三维场景出发，渲染成一张二维图像。这个过程由CPU,GPU共同完成。渲染流程分三个阶段：

## 应用阶段
应用阶段分三个任务（CPU负责实现）
1. 准备好场景数据。如场景所有GameObject信息，光照信息等。
2. 为了提高渲染性能，将相机不可见的物体剔除，这样就不用交给几何阶段处理了。
3. 设置每个模型的渲染状态，如使用的材质，纹理，Shader等。输出渲染所需的几何信息，即：<b>渲染图元</b>,渲染图元可以是点，线，三角面等。这些渲染图元将会传递到下一个阶段。

![shader_pip_line](https://cdn.jsdelivr.net/gh/TonyChenn/BlogPicture/2020/0926/shader_pipline.jpg)
## 几何阶段
几何阶段是用于处理所有要绘制的集合相关的事情。将上个阶段传递的渲染图元进行逐顶点，多边形进行处理。输出屏幕空间的二维顶点坐标，以及每个顶点的深度值，主色等相关信息，然后传递给光栅化阶段。这一阶段在GPU上进行。

## 光栅化阶段
光栅化阶段会将上一阶段传递过来的数据生成对应屏幕上的像素，并渲染出最终图像。这一阶段也是在GPU上进行。

# CPU与GPU的通信
渲染管线的起点是CPU,即应用阶段。应用阶段分为三个任务：
1. <b>把数据加载到显存中。</b>所有的渲染需要从<b>硬盘(HDD)</b>加载到<b>内存(RAM)</b>中，然后网格和纹理等数据又被加载到显存中，因为大多数显卡不能直接访问RAM,而且显卡读取显存速度也很快。当数据加载到显存后，RAM中一些CPU不再访问的数据即可移除掉了。但是之后还要使用的数据不能移除掉，毕竟从HDD加载到RAM还是很耗时的。之后通过CPU设置渲染状态进而指导GPU进行渲染。
2. <b>设置渲染状态。</b>渲染状态就是定义了场景中的网格该被如何渲染。如使用哪些顶点/片元着色器，光源属性，材质等。之后CPU调用DrawCall命令告诉GPU开始渲染。
3. <b>调用DrawCall。</b>DrawCall是一个渲染命令，由CPU发起，GPU接收。这个命令只会只想一个需要渲染的图元列表。当GPU收到DrawCall后，会根据渲染状态和顶点数据进行计算（[GPU的流水线](#GPU流水线)），最终显示到屏幕上。

# GPU流水线


# 什么是OpenGL/DirectX
OpenGL/DirectX 是图像应用编程接口，用来渲染二维，三维图形。如果没有 OpenGL/DirectX 想要访问GPU是很麻烦的，可能要和各种寄存器，显存打交道。OpenGL/DirectX将上层应用程序与底层GPU之间架起一座“桥梁”。

当应用程序通过上面编程接口后，这些接口会依次向<b>显卡驱动</b>发送渲染命令。<b>显卡驱动</b>会将OpenGL/DirectX中的函数翻译成GPU能懂的语言，实现与GPU的通讯。<b>显卡驱动</b>同时也会将纹理等数据转换为GPU支持的格式。

# HLSL，GLSL，CG的关系
HLSL，GLSL，CG是三种常见的着色器语言，用来编写着色器。这些语言会被编译为与机器无关的汇编语言（中间语言），中间语言再交给显卡翻译为真正的机器语言，即GPU可以理解的语言。

## 三者区别

<b>HLSL</b>基于DirectX,由微软控制，在版本相同时，不同平台编译的结果是一样的，但几乎只支持微软家产品，如: Windows,Xbox 360,PS3等。

<b>GLSL</b>基于OpenGL,优点在于跨平台性，只要显卡驱动支持即可正常工作，可以在Windows,Mac,Linux,移动平台工作。但是由于OpenGL不提供着色器编译器，而是由显卡驱动完成着色器编译，导致GLSL的编译结果取决于不用的显卡硬件厂商，进而导致编译结果不尽相同。

<b>CG</b>基于Nvidia，真正意义上的跨平台。根据不同的平台生成不同的中间语言。

# 为什么DrawCall多了会影响帧率？
CPU与GPU的并行工作应用了<b>并行缓冲区</b>.与生产者-消费者模型类似。CPU提交DrawCall到缓冲区，GPU从缓冲区取数据。
效率上，CPU要向GPU发送许多数据，以及检查工作，而GPU渲染能力很强，所以GPU从缓冲区取命令的速度远远大于CPU发送命令的速度。所以DrawCall过多会导致CPU过载。